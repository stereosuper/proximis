{"version":3,"sources":["webpack:///./node_modules/gsap/ScrollToPlugin.js","webpack:///./wp-content/themes/proximis/src/js/components/RefSlider.js","webpack:///./wp-content/themes/proximis/src/js/global/index.js","webpack:///./wp-content/themes/proximis/src/js/plugins/CustomEase.js"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;AAG1C,YAAY,sDAAQ,eAAe;AACnC,YAAY,sDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,oCAAoC;AACpC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sBAAsB,qKAAqK;AAC3L,eAAe;AACf,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;;AAEH,mBAAmB,sDAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,KAAK;AACL,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AClLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgE;AACrB;AACM;;AAEjB;AACG;;AAEnC;AACA,uBAAuB,2DAAc;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,QAAQ,6DAAa;AACrB;AACA;AACA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb,oBAAoB,aAAa;AACjC;AACA;AACA;AACA,aAAa;AACb;AACA,4BAA4B,YAAY;AACxC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,8CAAS;AACjB;AACA;AACA,aAAa;AACb,kBAAkB,8CAAM;AACxB,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAK;AACjC,wCAAwC,oBAAoB;AAC5D,aAAa;;AAEb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb,gBAAgB,gDAAO;AACvB;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,QAAQ,+DAAO;AACf;AACA,SAAS;AACT;AACA;AACA,QAAQ,+DAAO;AACf;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,uDAAuD,OAAO;;AAE9D;AACA;AACA;AACA;AACA,uDAAuD;AACvD,aAAa;AACb,sCAAsC,oBAAoB;AAC1D,SAAS;AACT;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,6DAAK;AACtC;AACA;AACA,SAAS;;AAET,2BAA2B,6DAAK;AAChC;AACA;AACA,SAAS;;AAET;;AAEA;;AAEA,QAAQ,6CAAQ;AAChB;AACA,SAAS;;AAET,QAAQ,6CAAQ;AAChB;AACA,SAAS;;AAET,QAAQ,6CAAQ;AAChB;AACA,kBAAkB,8CAAM;AACxB;AACA,gBAAgB,6CAAQ;AACxB;AACA,0BAA0B,8CAAM;AAChC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA,2BAA2B,6DAAK;AAChC,aAAa,oCAAoC;AACjD;AACA;AACA,iCAAiC,6DAAK;AACtC,aAAa,sCAAsC;AACnD;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,QAAQ,6CAAQ,sBAAsB,oBAAoB;;AAE1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8BAA8B,6DAAK,EAAE,oCAAoC;AACzE;;AAEA,yCAAyC,6DAAK;AAC9C;AACA;AACA,SAAS;;AAET,eAAe,SAAS;AACxB,QAAQ,6CAAQ;AAChB,uBAAuB,OAAO;AAC9B,kBAAkB,8CAAM;AACxB,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6DAAK,EAAE,6BAA6B;;AAEhE,QAAQ,+DAAO;AACf;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iDAAiD,iBAAiB;AAClE;AACA,iBAAiB;AACjB;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,6DAAK,EAAE,6BAA6B;AACrE;AACA,wBAAwB,6DAAK;AAC7B;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEe,+EAAgB,EAAC;;;;;;;;;;;;;AC7UhC;AAAA;AAAA;AAAmD;;AAE5C;AACP,YAAY,8DAAU;AACtB,aAAa,8DAAU;AACvB,eAAe,8DAAU;AACzB;;AAEe,gEAAC,SAAS,EAAC;;;;;;;;;;;;;ACR1B;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4D;;AAE5D,0DAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa,GAAG,aAAa;AAC7C;AACA;AACA,kDAAkD,mBAAmB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA,sCAAsC;AACtC,MAAM,OAAO;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;;AAEpB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,KAAK,OAAO;AACZ;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;;AAGJ;AACA;AACA;AACA;AACA,KAAK,sDAAI;AACT;AACA,8BAA8B;AAC9B;AACA,IAAI;AACJ,kCAAkC,sDAAI;;AAEtC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAc,OAAO;AACrB,UAAU;AACV,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA,+GAA+G;AAC/G,0CAA0C;AAC1C;AACA;AACA,4BAA4B;AAC5B,iHAAiH;AACjH;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe,OAAO,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI,OAAO;AACX,eAAe,OAAO,OAAO;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,UAAU,sDAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA,4FAA4F;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,EAAE;;AAEK,iBAAiB,yDAAO","file":"RefSlider.js","sourcesContent":["/*!\n * VERSION: 1.9.2\n * DATE: 2019-02-07\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n * \n * @author: Jack Doyle, jack@greensock.com\n **/\n/* eslint-disable */\n\nimport { _gsScope } from \"./TweenLite.js\";\n\n\nvar _doc = (_gsScope.document || {}).documentElement,\n\t\t_window = _gsScope,\n\t\t_max = function(element, axis) {\n\t\t\tvar dim = (axis === \"x\") ? \"Width\" : \"Height\",\n\t\t\t\tscroll = \"scroll\" + dim,\n\t\t\t\tclient = \"client\" + dim,\n\t\t\t\tbody = document.body;\n\t\t\treturn (element === _window || element === _doc || element === body) ? Math.max(_doc[scroll], body[scroll]) - (_window[\"inner\" + dim] || _doc[client] || body[client]) : element[scroll] - element[\"offset\" + dim];\n\t\t},\n\t\t_unwrapElement = function(value) {\n\t\t\tif (typeof(value) === \"string\") {\n\t\t\t\tvalue = TweenLite.selector(value);\n\t\t\t}\n\t\t\tif (value.length && value !== _window && value[0] && value[0].style && !value.nodeType) {\n\t\t\t\tvalue = value[0];\n\t\t\t}\n\t\t\treturn (value === _window || (value.nodeType && value.style)) ? value : null;\n\t\t},\n\t\t_buildGetter = function(e, axis) { //pass in an element and an axis (\"x\" or \"y\") and it'll return a getter function for the scroll position of that element (like scrollTop or scrollLeft, although if the element is the window, it'll use the pageXOffset/pageYOffset or the documentElement's scrollTop/scrollLeft or document.body's. Basically this streamlines things and makes a very fast getter across browsers.\n\t\t\tvar p = \"scroll\" + ((axis === \"x\") ? \"Left\" : \"Top\");\n\t\t\tif (e === _window) {\n\t\t\t\tif (e.pageXOffset != null) {\n\t\t\t\t\tp = \"page\" + axis.toUpperCase() + \"Offset\";\n\t\t\t\t} else if (_doc[p] != null) {\n\t\t\t\t\te = _doc;\n\t\t\t\t} else {\n\t\t\t\t\te = document.body;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn function() {\n\t\t\t\treturn e[p];\n\t\t\t};\n\t\t},\n\t\t_getOffset = function(element, container) {\n\t\t\tvar rect = _unwrapElement(element).getBoundingClientRect(),\n\t\t\t\tb = document.body,\n\t\t\t\tisRoot = (!container || container === _window || container === b),\n\t\t\t\tcRect = isRoot ? {top:_doc.clientTop - (window.pageYOffset || _doc.scrollTop || b.scrollTop || 0), left:_doc.clientLeft - (window.pageXOffset || _doc.scrollLeft || b.scrollLeft || 0)} : container.getBoundingClientRect(),\n\t\t\t\toffsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};\n\t\t\tif (!isRoot && container) { //only add the current scroll position if it's not the window/body.\n\t\t\t\toffsets.x += _buildGetter(container, \"x\")();\n\t\t\t\toffsets.y += _buildGetter(container, \"y\")();\n\t\t\t}\n\t\t\treturn offsets;\n\t\t\t/*\tPREVIOUS\n\t\t\tvar rect = _unwrapElement(element).getBoundingClientRect(),\n\t\t\t\tisRoot = (!container || container === _window || container === document.body),\n\t\t\t\tcRect = (isRoot ? _doc : container).getBoundingClientRect(),\n\t\t\t\toffsets = {x: rect.left - cRect.left, y: rect.top - cRect.top};\n\t\t\tif (!isRoot && container) { //only add the current scroll position if it's not the window/body.\n\t\t\t\toffsets.x += _buildGetter(container, \"x\")();\n\t\t\t\toffsets.y += _buildGetter(container, \"y\")();\n\t\t\t}\n\t\t\treturn offsets;\n\t\t\t*/\n\t\t},\n\t\t_parseVal = function(value, target, axis, currentVal) {\n\t\t\tvar type = typeof(value);\n\t\t\treturn !isNaN(value) ? parseFloat(value) : (type === \"string\" && value.charAt(1) === \"=\") ? parseInt(value.charAt(0) + \"1\", 10) * parseFloat(value.substr(2)) + currentVal : (value === \"max\") ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]);\n\t\t},\n\n\t\tScrollToPlugin = _gsScope._gsDefine.plugin({\n\t\t\tpropName: \"scrollTo\",\n\t\t\tAPI: 2,\n\t\t\tglobal: true,\n\t\t\tversion:\"1.9.2\",\n\n\t\t\t//called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.\n\t\t\tinit: function(target, value, tween) {\n\t\t\t\tthis._wdw = (target === _window);\n\t\t\t\tthis._target = target;\n\t\t\t\tthis._tween = tween;\n\t\t\t\tif (typeof(value) !== \"object\") {\n\t\t\t\t\tvalue = {y:value}; //if we don't receive an object as the parameter, assume the user intends \"y\".\n\t\t\t\t\tif (typeof(value.y) === \"string\" && value.y !== \"max\" && value.y.charAt(1) !== \"=\") {\n\t\t\t\t\t\tvalue.x = value.y;\n\t\t\t\t\t}\n\t\t\t\t} else if (value.nodeType) {\n\t\t\t\t\tvalue = {y:value, x:value};\n\t\t\t\t}\n\t\t\t\tthis.vars = value;\n\t\t\t\tthis._autoKill = (value.autoKill !== false);\n\t\t\t\tthis.getX = _buildGetter(target, \"x\");\n\t\t\t\tthis.getY = _buildGetter(target, \"y\");\n\t\t\t\tthis.x = this.xPrev = this.getX();\n\t\t\t\tthis.y = this.yPrev = this.getY();\n\t\t\t\tif (value.x != null) {\n\t\t\t\t\tthis._addTween(this, \"x\", this.x, _parseVal(value.x, target, \"x\", this.x) - (value.offsetX || 0), \"scrollTo_x\", true);\n\t\t\t\t\tthis._overwriteProps.push(\"scrollTo_x\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.skipX = true;\n\t\t\t\t}\n\t\t\t\tif (value.y != null) {\n\t\t\t\t\tthis._addTween(this, \"y\", this.y, _parseVal(value.y, target, \"y\", this.y) - (value.offsetY || 0), \"scrollTo_y\", true);\n\t\t\t\t\tthis._overwriteProps.push(\"scrollTo_y\");\n\t\t\t\t} else {\n\t\t\t\t\tthis.skipY = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t},\n\n\t\t\t//called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)\n\t\t\tset: function(v) {\n\t\t\t\tthis._super.setRatio.call(this, v);\n\n\t\t\t\tvar x = (this._wdw || !this.skipX) ? this.getX() : this.xPrev,\n\t\t\t\t\ty = (this._wdw || !this.skipY) ? this.getY() : this.yPrev,\n\t\t\t\t\tyDif = y - this.yPrev,\n\t\t\t\t\txDif = x - this.xPrev,\n\t\t\t\t\tthreshold = ScrollToPlugin.autoKillThreshold;\n\n\t\t\t\tif (this.x < 0) { //can't scroll to a position less than 0! Might happen if someone uses a Back.easeOut or Elastic.easeOut when scrolling back to the top of the page (for example)\n\t\t\t\t\tthis.x = 0;\n\t\t\t\t}\n\t\t\t\tif (this.y < 0) {\n\t\t\t\t\tthis.y = 0;\n\t\t\t\t}\n\t\t\t\tif (this._autoKill) {\n\t\t\t\t\t//note: iOS has a bug that throws off the scroll by several pixels, so we need to check if it's within 7 pixels of the previous one that we set instead of just looking for an exact match.\n\t\t\t\t\tif (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, \"x\")) {\n\t\t\t\t\t\tthis.skipX = true; //if the user scrolls separately, we should stop tweening!\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, \"y\")) {\n\t\t\t\t\t\tthis.skipY = true; //if the user scrolls separately, we should stop tweening!\n\t\t\t\t\t}\n\t\t\t\t\tif (this.skipX && this.skipY) {\n\t\t\t\t\t\tthis._tween.kill();\n\t\t\t\t\t\tif (this.vars.onAutoKill) {\n\t\t\t\t\t\t\tthis.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this._wdw) {\n\t\t\t\t\t_window.scrollTo((!this.skipX) ? this.x : x, (!this.skipY) ? this.y : y);\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.skipY) {\n\t\t\t\t\t\tthis._target.scrollTop = this.y;\n\t\t\t\t\t}\n\t\t\t\t\tif (!this.skipX) {\n\t\t\t\t\t\tthis._target.scrollLeft = this.x;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.xPrev = this.x;\n\t\t\t\tthis.yPrev = this.y;\n\t\t\t}\n\n\t\t}),\n\t\tp = ScrollToPlugin.prototype;\n\n\tScrollToPlugin.max = _max;\n\tScrollToPlugin.getOffset = _getOffset;\n\tScrollToPlugin.buildGetter = _buildGetter;\n\tScrollToPlugin.autoKillThreshold = 7;\n\n\tp._kill = function(lookup) {\n\t\tif (lookup.scrollTo_x) {\n\t\t\tthis.skipX = true;\n\t\t}\n\t\tif (lookup.scrollTo_y) {\n\t\t\tthis.skipY = true;\n\t\t}\n\t\treturn this._super._kill.call(this, lookup);\n\t};\n\n\nexport { ScrollToPlugin, ScrollToPlugin as default };","import { superPolyfill, query, forEach } from '@stereorepo/sac';\nimport { TweenMax, TweenLite } from 'gsap';\nimport ScrollToPlugin from 'gsap/ScrollToPlugin';\n\nimport Collant from './Collant';\nimport { easing } from '../global';\n\n// NOTE: We need to use ScrollToPlugin in order to ensure that the plugin won't be tree-shaked\nconst ensureScrollTo = ScrollToPlugin;\n\nclass ReferencesSlider {\n    constructor() {\n        this.state = {\n            transitioning: false\n        };\n\n        this.referenceSlider = null;\n        this.loader = null;\n        this.idsList = [];\n        this.slugsList = [];\n        this.collants = [];\n        this.currentReferenceId = 0;\n        this.newReferenceId = 0;\n        this.type = null;\n        this.currentSlide = null;\n\n        this.resetContext = this.resetContext.bind(this);\n\n        superPolyfill.initializeWhatwgFetch();\n    }\n    getAllSlideIds(callback) {\n        const action = 'get_references_ids';\n        const url = `/wp-admin/admin-ajax.php?action=${action}`;\n\n        fetch(url, {\n            method: 'GET',\n            headers: {\n                'Content-Type':\n                    'application/x-www-form-urlencoded; charset=utf-8'\n            }\n        })\n            .then(res => {\n                return res.json();\n            })\n            .then(({ ids, slugs }) => {\n                this.idsList = [...ids];\n                this.slugsList = [...slugs];\n                callback();\n            });\n    }\n    selectFollowingElement({ id = null }) {\n        if (id !== null) {\n            this.newReferenceId = id;\n        } else {\n            this.findFollowingElement();\n        }\n    }\n    findFollowingElement() {\n        const idIndex = this.idsList.indexOf(this.currentReferenceId);\n\n        if (this.type === 'next') {\n            this.newReferenceId =\n                idIndex + 2 > this.idsList.length\n                    ? this.idsList.slice(0, 1)\n                    : this.idsList.slice(idIndex + 1, idIndex + 2);\n        } else if (this.type === 'prev') {\n            this.newReferenceId =\n                idIndex - 1 < 0\n                    ? this.idsList.slice(-1)\n                    : this.idsList.slice(idIndex - 1, idIndex - 2);\n        }\n    }\n    scrollToReference() {\n        const offset =\n            window.scrollY + this.referenceSlider.getBoundingClientRect().top;\n\n        TweenLite.to(window, 0.5, {\n            scrollTo: {\n                y: offset\n            },\n            ease: easing.easeInOut\n        });\n    }\n    changeLocationHash(followingSlide) {\n        const slug = followingSlide.dataset.refSlug;\n\n        window.location.hash = slug;\n    }\n    checkLocationHash() {\n        const { hash } = window.location;\n        if (hash) {\n            if (this.state.transitioning) return;\n\n            const slugIndex = this.slugsList.indexOf(hash.replace('#', ''));\n            this.newReferenceId = this.idsList[slugIndex];\n\n            this.type = 'next';\n            this.state.transitioning = true;\n            this.scrollToReference();\n            this.checkLoadingCall();\n        }\n    }\n    checkLoadingCall() {\n        if (this.newReferenceId !== this.currentReferenceId) {\n            const [slide] = query({\n                selector: `.js-ref-id-${this.newReferenceId}`\n            });\n\n            if (slide) {\n                slide.classList.add('js-ref-following-slide');\n                this.slideAnimation();\n            } else {\n                this.startLoadingAction();\n            }\n        } else {\n            this.newReferenceId = null;\n            this.type = null;\n            this.state.transitioning = false;\n        }\n    }\n    stickElements() {\n        this.collants = [\n            ...this.collants,\n            new Collant({\n                ctx: this.currentSlide,\n                selector: '.js-nav-btn',\n                box: '.js-ref-first-part',\n                offsetTop: '100px'\n            }),\n            new Collant({\n                ctx: this.currentSlide,\n                selector: '.js-btn-download',\n                box: '.js-ref-content-wrapper',\n                offsetTop: '160px'\n            }),\n            new Collant({\n                ctx: this.currentSlide,\n                selector: '.js-infos-datas',\n                box: '.js-content-btn-infos',\n                offsetTop: '25px'\n            })\n        ];\n\n        forEach(this.collants, collant => {\n            collant.stickIt();\n        });\n    }\n    unstickElements() {\n        forEach(this.collants, collant => {\n            collant.ripIt();\n        });\n\n        this.collant = [];\n    }\n    startLoadingAction() {\n        this.loader.classList.add('loading');\n\n        const action = 'load_references';\n        const url = `/wp-admin/admin-ajax.php?action=${action}`;\n\n        fetch(url, {\n            method: 'POST',\n            headers: {\n                'Content-Type':\n                    'application/x-www-form-urlencoded; charset=utf-8'\n            },\n            body: `new_reference_id=${this.newReferenceId}`\n        })\n            .then(res => res.text())\n            .then(response => {\n                this.currentSlide.insertAdjacentHTML('afterend', response);\n\n                this.slideAnimation();\n            });\n    }\n    slideAnimation() {\n        let selector = '.js-ref-following-slide';\n        let xPercent = 0;\n        switch (this.type) {\n            case 'prev':\n                xPercent = -100;\n                break;\n            case 'next':\n                xPercent = 100;\n                break;\n            default:\n                xPercent = 100;\n                break;\n        }\n\n        const [followingSlide] = query({\n            selector,\n            ctx: this.referenceSlider\n        });\n\n        const [oldSlide] = query({\n            selector: '.js-ref-current-slide',\n            ctx: this.referenceSlider\n        });\n\n        this.changeLocationHash(followingSlide);\n\n        oldSlide.classList.remove('ref-slide-init');\n\n        TweenMax.set(followingSlide, {\n            xPercent\n        });\n\n        TweenMax.set(followingSlide, {\n            xPercent\n        });\n\n        TweenMax.to(oldSlide, 0.5, {\n            xPercent: -xPercent,\n            ease: easing.easeInOut,\n            onStart: () => {\n                TweenMax.to(followingSlide, 0.5, {\n                    xPercent: 0,\n                    ease: easing.easeInOut,\n                    onComplete: this.resetContext\n                });\n            }\n        });\n    }\n    resetContext() {\n        const [oldSlide] = query(\n            { selector: '.js-ref-current-slide' },\n            this.referenceSlider\n        );\n        const [followingSlide] = query(\n            { selector: '.js-ref-following-slide' },\n            this.referenceSlider\n        );\n\n        oldSlide.classList.remove('js-ref-current-slide');\n\n        followingSlide.classList.remove('js-ref-following-slide');\n        followingSlide.classList.add('js-ref-current-slide');\n\n        this.loader.classList.remove('loading');\n\n        TweenMax.set(followingSlide, { clearProps: 'all' });\n\n        this.currentReferenceId = 0;\n        this.newReferenceId = 0;\n        this.type = null;\n        this.currentSlide = null;\n\n        this.state.transitioning = false;\n        this.setCurrentContext();\n    }\n    setCurrentContext() {\n        if (this.idsList.length < 2) return;\n\n        this.unstickElements();\n\n        [this.currentSlide] = query({ selector: '.js-ref-current-slide' });\n        this.currentReferenceId = parseInt(this.currentSlide.dataset.refId, 10);\n\n        const [prevButton, nextButton] = query({\n            selector: '.js-button-hexagon',\n            ctx: this.currentSlide\n        });\n\n        const { height } = this.currentSlide.getBoundingClientRect();\n        TweenMax.to(this.referenceSlider, 0.3, {\n            height: `${height}px`,\n            ease: easing.easeInOut\n        });\n\n        prevButton.addEventListener(\n            'click',\n            () => {\n                if (this.state.transitioning) return;\n\n                this.type = 'prev';\n                this.changeSlide();\n            },\n            false\n        );\n        nextButton.addEventListener(\n            'click',\n            () => {\n                if (this.state.transitioning) return;\n\n                this.type = 'next';\n                this.changeSlide();\n            },\n            false\n        );\n\n        this.stickElements();\n    }\n    changeSlide() {\n        this.state.transitioning = true;\n        this.findFollowingElement();\n        this.checkLoadingCall();\n    }\n    initializeCaseStudyClickEvent() {\n        const caseStudies = query({ selector: '.js-case-study' });\n\n        forEach(caseStudies, caseStudy => {\n            caseStudy.addEventListener(\n                'click',\n                event => {\n                    event.preventDefault();\n                    if (this.state.transitioning) return;\n                    const selectedId = parseInt(caseStudy.dataset.refId, 10);\n\n                    this.scrollToReference();\n                    this.selectFollowingElement({ id: selectedId });\n                    this.checkLoadingCall();\n                },\n                false\n            );\n        });\n    }\n    initialize() {\n        [this.referenceSlider] = query({ selector: '.js-ref-slider' });\n        if (!this.referenceSlider) return;\n        [this.loader] = query({\n            selector: '.js-loader',\n            ctx: this.referenceSlider\n        });\n\n        this.getAllSlideIds(() => {\n            this.initializeCaseStudyClickEvent();\n            this.setCurrentContext();\n            this.checkLocationHash();\n        });\n    }\n}\n\nexport default ReferencesSlider;\n","import { CustomEase } from '../plugins/CustomEase';\n\nexport const easing = {\n    easeIn: CustomEase.create('custom', 'M0,0 C0.42,0.08, 0.45,0.09 1,1'),\n    easeOut: CustomEase.create('custom', 'M0,0 C0,0.15, 0.1,0.85 1,1'),\n    easeInOut: CustomEase.create('custom', 'M0,0 C0.38,0, 0.45,0.93 1,1')\n};\n\nexport default { easing };\n","/*!\n * VERSION: 0.2.2\n * DATE: 2018-08-27\n * UPDATES AND DOCS AT: http://greensock.com\n *\n * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.\n * This work is subject to the terms at http://greensock.com/standard-license or for\n * Club GreenSock members, the software agreement that was issued with your membership.\n *\n * @author: Jack Doyle, jack@greensock.com\n **/\n/* eslint-disable */\n\nimport { _gsScope, globals, Ease } from \"gsap/TweenLite.js\";\n\n_gsScope._gsDefine(\"easing.CustomEase\", [\"easing.Ease\"], function() {\n\n\t\tvar _numbersExp = /(?:(-|-=|\\+=)?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t\t_svgPathExp = /[achlmqstvz]|(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[0-9]/ig,\n\t\t\t_scientific = /[\\+\\-]?\\d*\\.?\\d+e[\\+\\-]?\\d+/ig,\n\t\t\t_needsParsingExp = /[cLlsS]/g,\n\t\t\t_bezierError = \"CustomEase only accepts Cubic Bezier data.\",\n\t\t\t_bezierToPoints = function (x1, y1, x2, y2, x3, y3, x4, y4, threshold, points, index) {\n\t\t\t\tvar x12 = (x1 + x2) / 2,\n\t\t\t\t\ty12 = (y1 + y2) / 2,\n\t\t\t\t\tx23 = (x2 + x3) / 2,\n\t\t\t\t\ty23 = (y2 + y3) / 2,\n\t\t\t\t\tx34 = (x3 + x4) / 2,\n\t\t\t\t\ty34 = (y3 + y4) / 2,\n\t\t\t\t\tx123 = (x12 + x23) / 2,\n\t\t\t\t\ty123 = (y12 + y23) / 2,\n\t\t\t\t\tx234 = (x23 + x34) / 2,\n\t\t\t\t\ty234 = (y23 + y34) / 2,\n\t\t\t\t\tx1234 = (x123 + x234) / 2,\n\t\t\t\t\ty1234 = (y123 + y234) / 2,\n\t\t\t\t\tdx = x4 - x1,\n\t\t\t\t\tdy = y4 - y1,\n\t\t\t\t\td2 = Math.abs((x2 - x4) * dy - (y2 - y4) * dx),\n\t\t\t\t\td3 = Math.abs((x3 - x4) * dy - (y3 - y4) * dx),\n\t\t\t\t\tlength;\n\t\t\t\tif (!points) {\n\t\t\t\t\tpoints = [{x: x1, y: y1}, {x: x4, y: y4}];\n\t\t\t\t\tindex = 1;\n\t\t\t\t}\n\t\t\t\tpoints.splice(index || points.length - 1, 0, {x: x1234, y: y1234});\n\t\t\t\tif ((d2 + d3) * (d2 + d3) > threshold * (dx * dx + dy * dy)) {\n\t\t\t\t\tlength = points.length;\n\t\t\t\t\t_bezierToPoints(x1, y1, x12, y12, x123, y123, x1234, y1234, threshold, points, index);\n\t\t\t\t\t_bezierToPoints(x1234, y1234, x234, y234, x34, y34, x4, y4, threshold, points, index + 1 + (points.length - length));\n\t\t\t\t}\n\t\t\t\treturn points;\n\t\t\t},\n\n\t\t\t_pathDataToBezier = function (d) {\n\t\t\t\tvar a = (d + \"\").replace(_scientific, function (m) {\n\t\t\t\t\t\t\tvar n = +m;\n\t\t\t\t\t\t\treturn (n < 0.0001 && n > -0.0001) ? 0 : n;\n\t\t\t\t\t\t}).match(_svgPathExp) || [], //some authoring programs spit out very small numbers in scientific notation like \"1e-5\", so make sure we round that down to 0 first.\n\t\t\t\t\tpath = [],\n\t\t\t\t\trelativeX = 0,\n\t\t\t\t\trelativeY = 0,\n\t\t\t\t\telements = a.length,\n\t\t\t\t\tl = 2,\n\t\t\t\t\ti, x, y, command, isRelative, segment, startX, startY, prevCommand, difX, difY;\n\t\t\t\tfor (i = 0; i < elements; i++) {\n\t\t\t\t\tprevCommand = command;\n\t\t\t\t\tif (isNaN(a[i])) {\n\t\t\t\t\t\tcommand = a[i].toUpperCase();\n\t\t\t\t\t\tisRelative = (command !== a[i]); //lower case means relative\n\t\t\t\t\t} else { //commands like \"C\" can be strung together without any new command characters between.\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n\t\t\t\t\tx = +a[i + 1];\n\t\t\t\t\ty = +a[i + 2];\n\t\t\t\t\tif (isRelative) {\n\t\t\t\t\t\tx += relativeX;\n\t\t\t\t\t\ty += relativeY;\n\t\t\t\t\t}\n\t\t\t\t\tif (!i) {\n\t\t\t\t\t\tstartX = x;\n\t\t\t\t\t\tstartY = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (command === \"M\") {\n\t\t\t\t\t\tif (segment && segment.length < 8) { //if the path data was funky and just had a M with no actual drawing anywhere, skip it.\n\t\t\t\t\t\t\tpath.length -= 1;\n\t\t\t\t\t\t\tl = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\trelativeX = startX = x;\n\t\t\t\t\t\trelativeY = startY = y;\n\t\t\t\t\t\tsegment = [x, y];\n\t\t\t\t\t\tl = 2;\n\t\t\t\t\t\tpath.push(segment);\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\tcommand = \"L\"; //an \"M\" with more than 2 values gets interpreted as \"lineTo\" commands (\"L\").\n\n\t\t\t\t\t} else if (command === \"C\") {\n\t\t\t\t\t\tif (!segment) {\n\t\t\t\t\t\t\tsegment = [0, 0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsegment[l++] = x;\n\t\t\t\t\t\tsegment[l++] = y;\n\t\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsegment[l++] = relativeX + a[i + 3] * 1; //note: \"*1\" is just a fast/short way to cast the value as a Number. WAAAY faster in Chrome, slightly slower in Firefox.\n\t\t\t\t\t\tsegment[l++] = relativeY + a[i + 4] * 1;\n\t\t\t\t\t\tsegment[l++] = relativeX = relativeX + a[i + 5] * 1;\n\t\t\t\t\t\tsegment[l++] = relativeY = relativeY + a[i + 6] * 1;\n\t\t\t\t\t\ti += 6;\n\n\t\t\t\t\t} else if (command === \"S\") {\n\t\t\t\t\t\tif (prevCommand === \"C\" || prevCommand === \"S\") {\n\t\t\t\t\t\t\tdifX = relativeX - segment[l - 4];\n\t\t\t\t\t\t\tdifY = relativeY - segment[l - 3];\n\t\t\t\t\t\t\tsegment[l++] = relativeX + difX;\n\t\t\t\t\t\t\tsegment[l++] = relativeY + difY;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsegment[l++] = relativeX;\n\t\t\t\t\t\t\tsegment[l++] = relativeY;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsegment[l++] = x;\n\t\t\t\t\t\tsegment[l++] = y;\n\t\t\t\t\t\tif (!isRelative) {\n\t\t\t\t\t\t\trelativeX = relativeY = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsegment[l++] = relativeX = relativeX + a[i + 3] * 1;\n\t\t\t\t\t\tsegment[l++] = relativeY = relativeY + a[i + 4] * 1;\n\t\t\t\t\t\ti += 4;\n\n\t\t\t\t\t} else if (command === \"L\" || command === \"Z\") {\n\t\t\t\t\t\tif (command === \"Z\") {\n\t\t\t\t\t\t\tx = startX;\n\t\t\t\t\t\t\ty = startY;\n\t\t\t\t\t\t\tsegment.closed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (command === \"L\" || Math.abs(relativeX - x) > 0.5 || Math.abs(relativeY - y) > 0.5) {\n\t\t\t\t\t\t\tsegment[l++] = relativeX + (x - relativeX) / 3;\n\t\t\t\t\t\t\tsegment[l++] = relativeY + (y - relativeY) / 3;\n\t\t\t\t\t\t\tsegment[l++] = relativeX + (x - relativeX) * 2 / 3;\n\t\t\t\t\t\t\tsegment[l++] = relativeY + (y - relativeY) * 2 / 3;\n\t\t\t\t\t\t\tsegment[l++] = x;\n\t\t\t\t\t\t\tsegment[l++] = y;\n\t\t\t\t\t\t\tif (command === \"L\") {\n\t\t\t\t\t\t\t\ti += 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\trelativeX = x;\n\t\t\t\t\t\trelativeY = y;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow _bezierError;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn path[0];\n\t\t\t},\n\n\t\t\t_findMinimum = function (values) {\n\t\t\t\tvar l = values.length,\n\t\t\t\t\tmin = 999999999999,\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 1; i < l; i += 6) {\n\t\t\t\t\tif (+values[i] < min) {\n\t\t\t\t\t\tmin = +values[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn min;\n\t\t\t},\n\n\t\t\t_normalize = function (values, height, originY) { //takes all the points and translates/scales them so that the x starts at 0 and ends at 1.\n\t\t\t\tif (!originY && originY !== 0) {\n\t\t\t\t\toriginY = Math.max(+values[values.length-1], +values[1]);\n\t\t\t\t}\n\t\t\t\tvar tx = +values[0] * -1,\n\t\t\t\t\tty = -originY,\n\t\t\t\t\tl = values.length,\n\t\t\t\t\tsx = 1 / (+values[l - 2] + tx),\n\t\t\t\t\tsy = -height || ((Math.abs(+values[l - 1] - +values[1]) < 0.01 * (+values[l - 2] - +values[0])) ? _findMinimum(values) + ty : +values[l - 1] + ty),\n\t\t\t\t\ti;\n\t\t\t\tif (sy) { //typically y ends at 1 (so that the end values are reached)\n\t\t\t\t\tsy = 1 / sy;\n\t\t\t\t} else { //in case the ease returns to its beginning value, scale everything proportionally\n\t\t\t\t\tsy = -sx;\n\t\t\t\t}\n\t\t\t\tfor (i = 0; i < l; i += 2) {\n\t\t\t\t\tvalues[i] = (+values[i] + tx) * sx;\n\t\t\t\t\tvalues[i + 1] = (+values[i + 1] + ty) * sy;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t_getRatio = function (p) {\n\t\t\t\tvar point = this.lookup[(p * this.l) | 0] || this.lookup[this.l - 1];\n\t\t\t\tif (point.nx < p) {\n\t\t\t\t\tpoint = point.n;\n\t\t\t\t}\n\t\t\t\treturn point.y + ((p - point.x) / point.cx) * point.cy;\n\t\t\t},\n\n\n\t\t\tCustomEase = function (id, data, config) {\n\t\t\t\tthis._calcEnd = true;\n\t\t\t\tthis.id = id;\n\t\t\t\tif (id) {\n\t\t\t\t\tEase.map[id] = this;\n\t\t\t\t}\n\t\t\t\tthis.getRatio = _getRatio; //speed optimization, faster lookups.\n\t\t\t\tthis.setData(data, config);\n\t\t\t},\n\t\t\tp = CustomEase.prototype = new Ease();\n\n\t\tp.constructor = CustomEase;\n\n\t\tp.setData = function(data, config) {\n\t\t\tdata = data || \"0,0,1,1\";\n\t\t\tvar values = data.match(_numbersExp),\n\t\t\t\tclosest = 1,\n\t\t\t\tpoints = [],\n\t\t\t\tl, a1, a2, i, inc, j, point, prevPoint, p, precision;\n\t\t\tconfig = config || {};\n\t\t\tprecision = config.precision || 1;\n\t\t\tthis.data = data;\n\t\t\tthis.lookup = [];\n\t\t\tthis.points = points;\n\t\t\tthis.fast = (precision <= 1);\n\t\t\tif (_needsParsingExp.test(data) || (data.indexOf(\"M\") !== -1 && data.indexOf(\"C\") === -1)) {\n\t\t\t\tvalues = _pathDataToBezier(data);\n\t\t\t}\n\t\t\tl = values.length;\n\t\t\tif (l === 4) {\n\t\t\t\tvalues.unshift(0, 0);\n\t\t\t\tvalues.push(1, 1);\n\t\t\t\tl = 8;\n\t\t\t} else if ((l - 2) % 6) {\n\t\t\t\tthrow _bezierError;\n\t\t\t}\n\t\t\tif (+values[0] !== 0 || +values[l - 2] !== 1) {\n\t\t\t\t_normalize(values, config.height, config.originY);\n\t\t\t}\n\n\t\t\tthis.rawBezier = values;\n\n\t\t\tfor (i = 2; i < l; i += 6) {\n\t\t\t\ta1 = {x: +values[i - 2], y: +values[i - 1]};\n\t\t\t\ta2 = {x: +values[i + 4], y: +values[i + 5]};\n\t\t\t\tpoints.push(a1, a2);\n\t\t\t\t_bezierToPoints(a1.x, a1.y, +values[i], +values[i + 1], +values[i + 2], +values[i + 3], a2.x, a2.y, 1 / (precision * 200000), points, points.length - 1);\n\t\t\t}\n\t\t\tl = points.length;\n\t\t\tfor (i = 0; i < l; i++) {\n\t\t\t\tpoint = points[i];\n\t\t\t\tprevPoint = points[i - 1] || point;\n\t\t\t\tif (point.x > prevPoint.x || (prevPoint.y !== point.y && prevPoint.x === point.x) || point === prevPoint) { //if a point goes BACKWARD in time or is a duplicate, just drop it.\n\t\t\t\t\tprevPoint.cx = point.x - prevPoint.x; //change in x between this point and the next point (performance optimization)\n\t\t\t\t\tprevPoint.cy = point.y - prevPoint.y;\n\t\t\t\t\tprevPoint.n = point;\n\t\t\t\t\tprevPoint.nx = point.x; //next point's x value (performance optimization, making lookups faster in getRatio()). Remember, the lookup will always land on a spot where it's either this point or the very next one (never beyond that)\n\t\t\t\t\tif (this.fast && i > 1 && Math.abs(prevPoint.cy / prevPoint.cx - points[i - 2].cy / points[i - 2].cx) > 2) { //if there's a sudden change in direction, prioritize accuracy over speed. Like a bounce ease - you don't want to risk the sampling chunks landing on each side of the bounce anchor and having it clipped off.\n\t\t\t\t\t\tthis.fast = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (prevPoint.cx < closest) {\n\t\t\t\t\t\tif (!prevPoint.cx) {\n\t\t\t\t\t\t\tprevPoint.cx = 0.001; //avoids math problems in getRatio() (dividing by zero)\n\t\t\t\t\t\t\tif (i === l - 1) { //in case the final segment goes vertical RIGHT at the end, make sure we end at the end.\n\t\t\t\t\t\t\t\tprevPoint.x -= 0.001;\n\t\t\t\t\t\t\t\tclosest = Math.min(closest, 0.001);\n\t\t\t\t\t\t\t\tthis.fast = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclosest = prevPoint.cx;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpoints.splice(i--, 1);\n\t\t\t\t\tl--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tl = (1 / closest + 1) | 0;\n\t\t\tthis.l = l; //record for speed optimization\n\t\t\tinc = 1 / l;\n\t\t\tj = 0;\n\t\t\tpoint = points[0];\n\t\t\tif (this.fast) {\n\t\t\t\tfor (i = 0; i < l; i++) { //for fastest lookups, we just sample along the path at equal x (time) distance. Uses more memory and is slightly less accurate for anchors that don't land on the sampling points, but for the vast majority of eases it's excellent (and fast).\n\t\t\t\t\tp = i * inc;\n\t\t\t\t\tif (point.nx < p) {\n\t\t\t\t\t\tpoint = points[++j];\n\t\t\t\t\t}\n\t\t\t\t\ta1 = point.y + ((p - point.x) / point.cx) * point.cy;\n\t\t\t\t\tthis.lookup[i] = {x: p, cx: inc, y: a1, cy: 0, nx: 9};\n\t\t\t\t\tif (i) {\n\t\t\t\t\t\tthis.lookup[i - 1].cy = a1 - this.lookup[i - 1].y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.lookup[l - 1].cy = points[points.length - 1].y - a1;\n\t\t\t} else { //this option is more accurate, ensuring that EVERY anchor is hit perfectly. Clipping across a bounce, for example, would never happen.\n\t\t\t\tfor (i = 0; i < l; i++) { //build a lookup table based on the smallest distance so that we can instantly find the appropriate point (well, it'll either be that point or the very next one). We'll look up based on the linear progress. So it's it's 0.5 and the lookup table has 100 elements, it'd be like lookup[Math.floor(0.5 * 100)]\n\t\t\t\t\tif (point.nx < i * inc) {\n\t\t\t\t\t\tpoint = points[++j];\n\t\t\t\t\t}\n\t\t\t\t\tthis.lookup[i] = point;\n\t\t\t\t}\n\n\t\t\t\tif (j < points.length - 1) {\n\t\t\t\t\tthis.lookup[i-1] = points[points.length-2];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._calcEnd = (points[points.length-1].y !== 1 || points[0].y !== 0); //ensures that we don't run into floating point errors. As long as we're starting at 0 and ending at 1, tell GSAP to skip the final calculation and use 0/1 as the factor.\n\t\t\treturn this;\n\t\t};\n\n\t\tp.getRatio = _getRatio;\n\n\t\tp.getSVGData = function(config) {\n\t\t\treturn CustomEase.getSVGData(this, config);\n\t\t};\n\n\t\tCustomEase.create = function (id, data, config) {\n\t\t\treturn new CustomEase(id, data, config);\n\t\t};\n\n\t\tCustomEase.version = \"0.2.2\";\n\n\t\tCustomEase.bezierToPoints = _bezierToPoints;\n\t\tCustomEase.get = function (id) {\n\t\t\treturn Ease.map[id];\n\t\t};\n\t\tCustomEase.getSVGData = function(ease, config) {\n\t\t\tconfig = config || {};\n\t\t\tvar rnd = 1000,\n\t\t\t\twidth = config.width || 100,\n\t\t\t\theight = config.height || 100,\n\t\t\t\tx = config.x || 0,\n\t\t\t\ty = (config.y || 0) + height,\n\t\t\t\te = config.path,\n\t\t\t\ta, slope, i, inc, tx, ty, precision, threshold, prevX, prevY;\n\t\t\tif (config.invert) {\n\t\t\t\theight = -height;\n\t\t\t\ty = 0;\n\t\t\t}\n\t\t\tease = ease.getRatio ? ease : Ease.map[ease] || console.log(\"No ease found: \", ease);\n\t\t\tif (!ease.rawBezier) {\n\t\t\t\ta = [\"M\" + x + \",\" + y];\n\t\t\t\tprecision = Math.max(5, (config.precision || 1) * 200);\n\t\t\t\tinc = 1 / precision;\n\t\t\t\tprecision += 2;\n\t\t\t\tthreshold = 5 / precision;\n\t\t\t\tprevX = (((x + inc * width) * rnd) | 0) / rnd;\n\t\t\t\tprevY = (((y + ease.getRatio(inc) * -height) * rnd) | 0) / rnd;\n\t\t\t\tslope = (prevY - y) / (prevX - x);\n\t\t\t\tfor (i = 2; i < precision; i++) {\n\t\t\t\t\ttx = (((x + i * inc * width) * rnd) | 0) / rnd;\n\t\t\t\t\tty = (((y + ease.getRatio(i * inc) * -height) * rnd) | 0) / rnd;\n\t\t\t\t\tif (Math.abs((ty - prevY) / (tx - prevX) - slope) > threshold || i === precision - 1) { //only add points when the slope changes beyond the threshold\n\t\t\t\t\t\ta.push(prevX + \",\" + prevY);\n\t\t\t\t\t\tslope = (ty - prevY) / (tx - prevX);\n\t\t\t\t\t}\n\t\t\t\t\tprevX = tx;\n\t\t\t\t\tprevY = ty;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ta = [];\n\t\t\t\tprecision = ease.rawBezier.length;\n\t\t\t\tfor (i = 0; i < precision; i += 2) {\n\t\t\t\t\ta.push((((x + ease.rawBezier[i] * width) * rnd) | 0) / rnd + \",\" + (((y + ease.rawBezier[i + 1] * -height) * rnd) | 0) / rnd);\n\t\t\t\t}\n\t\t\t\ta[0] = \"M\" + a[0];\n\t\t\t\ta[1] = \"C\" + a[1];\n\t\t\t}\n\t\t\tif (e) {\n\t\t\t\t(typeof(e) === \"string\" ? document.querySelector(e) : e).setAttribute(\"d\", a.join(\" \"));\n\t\t\t}\n\t\t\treturn a.join(\" \");\n\t\t};\n\n\t\treturn CustomEase;\n\n\t}, true);\n\nexport var CustomEase = globals.CustomEase;\nexport { CustomEase as default };"],"sourceRoot":""}